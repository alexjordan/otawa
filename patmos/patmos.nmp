let proc	= "patmos"
let bit_order	= "uppermost"
let gliss_isize = "32,64"

// -- Types --
type word       = card(32)
type half       = card(16)
type byte       = card(8)
type bit        = card(1)

type u32 	= card(32)
type u16	= card(16)
type u8         = card(8)

// Constants
let NUM_GPR	  = 32
let NUM_SPR       = 16
let NUM_PRR       = 8
let MEM_ADDR_SIZE = 32

// Global memory
mem M   [ MEM_ADDR_SIZE, u8 ]
mem M16 [ MEM_ADDR_SIZE >> 1, u16 ] alias = M[0]
mem M32 [ MEM_ADDR_SIZE >> 2, u32 ] alias = M[0]

// Local memories
mem LM   [ MEM_ADDR_SIZE, u8 ]
mem LM16 [ MEM_ADDR_SIZE >> 1, u16 ] alias = LM[0]
mem LM32 [ MEM_ADDR_SIZE >> 2, u32 ] alias = LM[0]


// ---- Registers ----

// Registers
reg R	[ NUM_GPR, word ]
reg S   [ NUM_SPR, word ]
reg PC	[ 1, word ]	pc = 1
reg nPC	[ 1, word ]	npc = 1


// Special registers, register aliases
reg SZ [ 1, word ]      alias = S[0]
reg SM [ 1, word ]      alias = S[1]
reg SL [ 1, word ]      alias = S[2]
reg SH [ 1, word ]      alias = S[3]
reg SS [ 1, word ]      alias = S[5]
reg ST [ 1, word ]      alias = S[6]
reg SRB [ 1, word ]     alias = S[7]
reg SRO [ 1, word ]     alias = S[8]
reg SXB [ 1, word ]     alias = S[9]
reg SXO [ 1, word ]     alias = S[10]

reg RTMP [ 1, word ]    alias = R[29]
reg RFP  [ 1, word ]    alias = R[30]
reg RSP  [ 1, word ]    alias = R[31]


// Type for GPR operands
mode reg_idx(i: card(5)) = R[i]
  syntax = format("$r%d", i)
  image = format("%5b", i)
  // attribute is true if this is the zero register
  is_zero = (i == 0)

// Type for SPR operands
mode sreg_idx(i: card(4)) = S[i]
  syntax = format("$s%d", i)
  image = format("%4b", i)

// Type for predicate operand (no negate bit)
mode pred_idx(i: card(3)) = SZ<i..i>
  syntax = format("$p%d", i)
  image = format("%3b", i)

// Type for predicate operand (with negate bit)
mode npred_idx(n: bit, i: card(3)) = if n then !SZ<i..i> else SZ<i..i> endif
  syntax = format("%s$p%d", if n then "!" else "" endif, i)
  image = format("%1b%3b", n, i)

// Type for predicate guards (predicate with negate bit used as guard)
mode gpred_idx(n: bit, i: card(3)) = if n then !SZ<i..i> else SZ<i..i> endif
  syntax = if n == 0 && i == 0 then
             "      "
	   else
             format("(%s$p%d)", if n then "!" else " " endif, i)
	   endif
  image = format("%1b%3b", n, i)




// Macros to update register values
macro setGPR(r, v) = if r != 0 then R[r] = v; endif

macro setPred(p, v) = if p != 0 then SZ<p> = v; endif


// initialization, Patmos specific.
op init()
  action =
      {
	  // Initialize read-only register
	  R[0] = 0;

	  // Initialize predicates
	  SZ = 0;

	  // Note: pcs will be properly init at exec loading
	  PC = 0;
	  nPC = 4;
      }



// ---- Instructions ----

// Base class for all instructions
op instruction (x : Patmos_instr)
  syntax = x.syntax
  image = x.image
  action =
      {
	  x.action;
	  PC = nPC;
	  // TODO the PC is increased depending on the bundle/ALUl type
	  nPC = nPC + 4;
      }

// All instructions are predicated
op Patmos_instr = Pred_fmt


op Pred_instr = ALU_instr
	      | SPC_instr
	      | LDT_instr
	      | STT_instr
	      | STC_instr
	      | CFL_instr


// Predicated instructions:
// <bundle bit> <predicate> <instr>
op Pred_fmt (b: bit, p: gpred_idx, x: Pred_instr)
  syntax = format("%s %s %s", if b then "{" else " " endif, p, x)
  image = format("%1b %s %s", b, p, x)
  action = 
      {
	if p then
	  x.action;
	endif;
      }


op ALU_instr = ALUi_fmt
             | ALUl_fmt
             | ALU_fmt

op SPC_instr = SPC_fmt

op LDT_instr = LDT_fmt

op STT_instr = STT_fmt

op STC_instr = STC_fmt

op CFL_instr = CFLi_fmt 
             | CFLr_fmt


op ALU_fmt = ALUr_fmt
           | ALUm_fmt
           | ALUc_fmt
	   | ALUci_fmt
           | ALUp_fmt
           | ALUb_fmt

op SPC_fmt = SPCt_fmt
           | SPCf_fmt
	   | SPCw_fmt

op STC_fmt = STCi_fmt
           | STCr_fmt

op CFLr_fmt = CFLri_fmt
            | CFLrs_fmt
	    | CFLrt_fmt



op ALU_op(opc: card(3))
  syntax = 
      switch (opc)
      {
	case 0:  "add   "
	case 1:  "sub   "
	case 2:  "xor   "
	case 3:  "sl    "
	case 4:  "sr    "
	case 5:  "sra   "
	case 6:  "or    "
	case 7:  "and   "
      }
  image = format("%3b", opc)
  // True if this is a 'add' opcode
  is_add = (opc == 0)
  // True if this is a 'sub' opcode
  is_sub = (opc == 1)
  // True if this is any kind of shift operation
  is_shift = (opc == 3 || opc == 4 || opc == 5)

op ALU_extop(opc: card(4))
  syntax = 
      switch (opc)
      {
	case 0:   "add   "
	case 1:   "sub   "
	case 2:   "xor   "
	case 3:   "sl    "
	case 4:   "sr    "
	case 5:   "sra   "
	case 6:   "or    "
	case 7:   "and   "
	case 11:  "nor   "
	case 12:  "shadd "
	case 13:  "shadd2"
	default:  "undef!"
      }
  image = format("%4b", opc)
  // True if this is a 'sub' opcode
  is_sub = (opc == 1)
  // True if this is any kind of shift operation
  is_shift = (opc == 3 || opc == 4 || opc == 5 || opc == 12 || opc == 13)

op ALUm_op(opc: card(4))
  syntax = 
      switch (opc)
      {
	case 0:  "mul   "
	case 1:  "mulu  "
	default: "undef!"
      }
  image = format("%4b", opc)

op ALUc_op(opc: card(4))
  syntax = 
      switch (opc)
      {
	case 0:  "cmpeq "
	case 1:  "cmpneq"
	case 2:  "cmplt "
	case 3:  "cmple "
	case 4:  "cmpult"
	case 5:  "cmpule"
	case 6:  "btest "
	default: "undef!"
      }
  image = format("%4b", opc)

op ALUp_op(opc: card(4))
  syntax = 
      switch (opc)
      {
	case 6:  "por   "
	case 7:  "pand  "
	case 10: "pxor  "
	default: "undef!"
      }
  image = format("%4b", opc)

op ALUi_fmt(func: ALU_op, rd: reg_idx, rs1: reg_idx, imm12: card(12))
  syntax = if func.is_sub && rs1.is_zero then
             if rd.is_zero && imm12 == 0 then
               "nop"
	     else
	       format("li    %s = -%d", rd, imm12)
	     endif
	   else
	     if func.is_add && rs1.is_zero && imm12 == 0 then
	       format("clr    %s", rd)
	     else
	       if func.is_add && rs1.is_zero then
		 format("li     %s = %d", rd, imm12)
	       else
		 if func.is_add && imm12 == 0 then
		   format("mov    %s = %s", rd, rs1)
		 else
		   format("%s %s = %s, %d", func, rd, rs1, imm12)
		 endif
	       endif
	     endif
	   endif
  image = format("00 %s %s %s %12b", func, rd, rs1, imm12)
  action = { }

op ALUl_fmt(func: ALU_extop, rd: reg_idx, rs1: reg_idx, imm32: card(32))
  syntax = format("%s %s = %s, %d", func, rd, rs1, imm32)
  image = format("11111 %s %s XXXXX 000 %s %32b", rd, rs1, func, imm32)
  action = { }

op ALUr_fmt(func: ALU_extop, rd: reg_idx, rs1: reg_idx, rs2: reg_idx)
  syntax = format("%s %s = %s, %s", func, rd, rs1, rs2)
  image = format("01000 %s %s %s 000 %s", rd, rs1, rs2, func)
  action = { }

op ALUm_fmt(func: ALUm_op, rs1: reg_idx, rs2: reg_idx)
  syntax = format("%s %s, %s", func, rs1, rs2)
  image = format("01000 XXXXX %s %s 010 %s", rs1, rs2, func)
  action = { }

op ALUc_fmt(func: ALUc_op, pd: pred_idx, rs1: reg_idx, rs2: reg_idx)
  syntax = format("%s %s = %s, %s", func, pd, rs1, rs2)
  image = format("01000 XX %s %s %s 011 %s", pd, rs1, rs2, func)
  action = { }

op ALUci_fmt(func: ALUc_op, pd: pred_idx, rs1: reg_idx, imm5: card(5))
  syntax = format("%s %s = %s, %d", func, pd, rs1, imm5)
  image = format("01000 XX %s %s %5b 110 %s", pd, rs1, imm5, func)
  action = { }

op ALUp_fmt(func: ALUp_op, pd: pred_idx, ps1: npred_idx, ps2: npred_idx)
  syntax = format("%s %s = %s, %s", func, pd, ps1, ps2)
  image = format("01000 XX %s X %s X %s 100 %s", pd, ps1, ps2, func)
  action = { }

op ALUb_fmt(rd: reg_idx, rs1: reg_idx, imm5: card(5), ps: npred_idx)
  syntax = format("bcopy  %s = %s, %d, %s", rd, rs1, imm5, ps)
  image = format("01000 %s %s %5b 101 %s", rd, rs1, imm5, ps)
  action = { }



op SPCw_op(opc: card(4))
  syntax = 
      switch (opc)
      {
	case 0:  "wait.mem"
	default: "undef!"
      }
  image = format("%4b", opc)

op SPCw_fmt(func: SPCw_op)
  syntax = format("%s", func)
  image = format("01001 XXXXXXXXXXXXXXX 001 %s", func)
  action = { }

op SPCt_fmt(rs1: reg_idx, sd: sreg_idx)
  syntax = format("mts    %s = %s", sd, rs1)
  image = format("01001 XXXXX %s XXXXX 010 %s", rs1, sd)
  action = { }

op SPCf_fmt(rd: reg_idx, ss: sreg_idx)
  syntax = format("mfs    %s = %s", rd, ss)
  image = format("01001 %s XXXXX XXXXX 011 %s", rd, ss)
  action = { }


op LDT_op(opc: card(5))
  syntax = 
      switch (opc)
      {
	case  0: "lws   "
	case  1: "lwl   "
	case  2: "lwc   "
	case  3: "lwm   "
	case  4: "lhs   "
	case  5: "lhl   "
	case  6: "lhc   "
	case  7: "lhm   "
	case  8: "lbs   "
	case  9: "lbl   "
	case 10: "lbc   "
	case 11: "lbm   "
	case 12: "lhus  "
	case 13: "lhul  "
	case 14: "lhuc  "
	case 15: "lhum  "
	case 16: "lbus  "
	case 17: "lbul  "
	case 18: "lbuc  "
	case 19: "lbum  "
	case 20: "dlwc  "
	case 21: "dlwm  "
	case 22: "dlhc  "
	case 23: "dlhm  "
	case 24: "dlbc  "
	case 25: "dlbm  "
	case 26: "dlhuc "
	case 27: "dlhum "
	case 28: "dlbuc "
	case 29: "dlbum "
	default: "undef!"
      }
  image = format("%5b", opc)
  is_decoupled = (opc >= 20)

op STT_op(opc: card(5))
  syntax = 
      switch (opc)
      {
  case  0: "sws   "
	case  1: "swl   "
	case  2: "swc   "
	case  3: "swm   "
	case  4: "shs   "
	case  5: "shl   "
	case  6: "shc   "
	case  7: "shm   "
	case  8: "sbs   "
	case  9: "sbl   "
	case 10: "sbc   "
	case 11: "sbm   "
	default: "undef!"
      }
  image = format("%5b", opc)


op LDT_fmt(func: LDT_op, rd: reg_idx, ra: reg_idx, imm7: card(7))
  syntax = if ra.is_zero then
             format("%s %s = [%d]", func, rd, imm7)
	   else
	     if imm7 == 0 then
               format("%s %s = [%s]", func, rd, ra)
	     else
               format("%s %s = [%s + %d]", func, rd, ra, imm7)
	     endif
	   endif
  image = format("01010 %s %s %s %7b", rd, ra, func, imm7) 
  action = { }

op STT_fmt(func: STT_op, ra: reg_idx, rs: reg_idx, imm7: card(7))
  syntax = if ra.is_zero then
             format("%s [%d] = %s", func, imm7, rs)
	   else
	     if imm7 == 0 then
               format("%s [%s] = %s", func, ra, rs)
	     else
               format("%s [%s + %d] = %s", func, ra, imm7, rs)
	     endif
	   endif
  image = format("01011 %s %s %s %7b", func, ra, rs, imm7) 
  action = { }


op STC_op(opc: card(2))
  syntax = 
      switch (opc)
      {
	case 0:  "sres  "
	case 1:  "sens  "
	case 2:  "sfree "
	case 3:  "sspill"
      }
  image = format("%2b", opc)

op STCi_fmt(func: STC_op, imm18: card(18))
  syntax = format("%s %d", func, imm18)
  image = format("01100 %s 00 %18b", func, imm18)
  action = { }

op STCr_fmt(func: STC_op, rs: reg_idx)
  syntax = format("%s %s", func, rs)
  image = format("01100 %s 01 X %s XXXXX XXXXXXX", func, rs)
  action = { }



op CFL_op(opc: card(2))
  syntax = 
      switch (opc)
      {
	case 0:  "call"
	case 1:  "br"
	case 2:  "brcf"
	case 3:  "trap"
      }
  image = format("%2b", opc)
  // Does this use a PC relative or an absolute immediate?
  is_PCRel = (opc == 1)
  // Is this a call instruction
  is_call = (opc == 0)
  // Is this a trap instruction
  is_trap = (opc == 3)

op CFLret_op(opc: card(2))
  syntax = 
      switch (opc)
      {
	case 0:  "ret"
	case 1:  "xret"
	default: "undef!"
      }
  image = format("%2b", opc)

op CFLi_fmt(func: CFL_op, d: bit, imm22: card(22))
  // This is a workaround for gliss type/size conversion to signed.
  syntax = format("%s%s %d", func, if d then "" else "nd" endif, 
                                   if func.is_PCRel then (coerce(int(32), imm22)<<10)>>10 else imm22 endif)
  image = format("10 %s %1b %22b", func, d, imm22)
  action = { }

op CFLri_fmt(func: CFLret_op, d: bit)
  syntax = format("%s%s", func, if d then "" else "nd" endif)
  image = format("1100 %1b XXXXX XXXXX XXXXX XXX 00 %s", d, func)
  action = { }

op CFLrs_fmt(func: CFL_op, d: bit, rs1: reg_idx)
  syntax = format("%s%s %s", func, if d then "" else "nd" endif, rs1)
  image = format("1100 %1b XXXXX %s XXXXX XXX 01 %s", d, rs1, func)
  action = { }

op CFLrt_fmt(func: CFL_op, d: bit, rs1: reg_idx, rs2: reg_idx)
  syntax = format("%s%s %s, %s", func, if d then "" else "nd" endif, rs1, rs2)
  image = format("1100 %1b XXXXX %s %s XXX 10 %s", d, rs1, rs2, func)
  action = { }


