// canonicals
canon s32 "_R"(u32)
canon s32 "_S"(u32) 
canon u32 "_MCB"

canon "_NOP"()
canon "_BRANCH"(u32)
canon "_TRAP"()
canon "_CONT"()
canon "_IF"(u32, u32, u32)
canon "_LOAD"(u32, u32, u32)
canon "_STORE"(u32, u32, u32)
canon "_SCRATCH"(u32)
canon "_SET"(u32, u32)
canon "_SETI"(u32, s32)
canon "_CMP"(u32, s32, s32)
canon "_CMPU"(u32, u32, u32)
canon "_ADD"(u32, u32, u32)
canon "_SUB"(u32, u32, u32)
canon "_SHL"(u32, u32, u32)
canon "_SHR"(u32, u32, u32)
canon "_ASR"(u32, u32, u32)
canon "_NOT"(u32, u32)
canon "_AND"(u32, u32, u32)
canon "_OR"(u32, u32, u32)
canon "_MUL"(s32, s32, s32)
canon "_MULU"(u32, u32, u32)
canon "_XOR"(u32, u32, u32)

// condition codes
canon u32 "_NO_COND"
canon u32 "_EQ"
canon u32 "_LT"
canon u32 "_LE"
canon u32 "_GE"
canon u32 "_GT"
canon u32 "_ANY_COND"
canon u32 "_NE"
canon u32 "_ULT"
canon u32 "_ULE"
canon u32 "_UGE"
canon u32 "_UGT"

// special registers
macro SZ = "_S"(0) 
macro SM = "_S"(1) 
macro SL = "_S"(2) 
macro SH = "_S"(3) 
macro SS = "_S"(5) 
macro ST = "_S"(6) 
macro SRB = "_S"(7) 
macro SRO = "_S"(8) 
macro SXB = "_S"(9) 
macro SXO = "_S"(10)

// operands
let T1 = -1
let T2 = -2
macro RD = "_R"(rd.value)
macro RS1 = "_R"(rs1.value)
macro RS2 = "_R"(rs2.value)
macro IMM = rs2.value

// operations
macro NOP = "_NOP"()
macro BRANCH(a) = "_BRANCH"(a)
macro TRAP = "_TRAP"()
macro CONT = "_CONT"()
macro IF(a,b,c) = "_IF"(a,b,c)
macro LOAD(d, s1, s2) = "_LOAD"(d, s1, s2)
macro STORE(d, s1, s2) = "_STORE"(d, s1, s2)
macro SCRATCH(d) = "_SCRATCH"(d)
macro SET(d, s) = "_SET"(d, s)
macro SETI(d, i) = "_SETI"(d, i)
macro CMP(d, s1, s2) = "_CMP"(d, s1, s2)
macro CMPU(d, s1, s2) = "_CMPU"(d, s1, s2)
macro ADD(d, s1, s2) = "_ADD"(d, s1, s2)
macro SUB(d, s1, s2) = "_SUB"(d, s1, s2)
macro SHL(d, s1, s2) = "_SHL"(d, s1, s2)
macro SHR(d, s1, s2) = "_SHR"(d, s1, s2)
macro ASR(d, s1, s2) = "_ASR"(d, s1, s2)
macro NOT(d, s) = "_NOT"(d, s)
macro AND(d, s1, s2) = "_AND"(d, s1, s2)
macro OR(d, s1, s2) = "_OR"(d, s1, s2)
macro MUL(d, s1, s2) = "_MUL"(d, s1, s2)
macro MULU(d, s1, s2) = "_MULU"(d, s1, s2)
macro XOR(d, s1, s2) = "_XOR"(d, s1, s2)

macro SHLI(d, s, i) = "_SETI"(T1, i); "_SHL"(d, s, T1)
macro SHRI(d, s, i) = "_SETI"(T1, i); "_SHR"(d, s, T1)
macro ASHRI(d, s, i) = "_SETI"(T1, i); "_ASR"(d, s, T1)
macro ADDI(d, s, i) = "_SETI"(T1, i); "_ADD"(d, s, T1)
macro SUBI(d, s, i) = "_SETI"(T1, i); "_SUB"(d, s, T1)
macro ANDI(d, s, i) = "_SETI"(T1, i); "_AND"(d, s, T1)
macro XORI(d, s, i) = "_SETI"(T1, i); "_XOR"(d, s, T1)

// temporaries
var t1[1, u32]
var r2[1, u32]

// translating conditions
macro get_cond(c) = \
	switch (c) { \
		case 0:		"_NO_COND"	\
		case 1:		"_EQ" \
		case 2:		"_LE" \
		case 3:		"_LT" \
		case 4:		"_ULE" \
		case 5:		"_ULT" \
		case 6:		"_ANY_COND" \
		case 7:		"_ANY_COND" \
		case 8:		"_NO_COND" \
		case 9:		"_NE" \
		case 0xa:	"_GT" \
		case 0xb:	"_GE" \
		case 0xc:	"_UGT" \
		case 0xd:	"_UGE" \
		case 0xe:	"_ANY_COND" \
		case 0xf:	"_ANY_COND" \
		default:	"_ANY_COND" \
	}



extend Pred_fmt
	otawa_sem = {
	  if !guard.always_true then
	    // IF(,1)
	    CONT;
	  endif;
	  x.otawa_sem;
	}

extend ALUi_fmt
	otawa_sem = {
	  if !rd.is_zero then
	    SETI(t1, imm12);
	    ADD(rd, rs1, t1);
	  endif;
	}

extend ALUl_fmt
	otawa_sem = {
	}

extend ALUr_fmt
	otawa_sem = {
	}

extend ALUm_fmt
	otawa_sem = {
	}

extend ALUc_fmt
	otawa_sem = {
	}

extend ALUci_fmt
	otawa_sem = {
	}

extend ALUp_fmt
	otawa_sem = {
	}

extend ALUb_fmt
	otawa_sem = {
	}

extend SPCw_fmt
	otawa_sem = {
	}

extend SPCt_fmt
	otawa_sem = {
	}

extend SPCf_fmt
	otawa_sem = {
	}

extend LDT_fmt
	otawa_sem = {
	}

extend STT_fmt
	otawa_sem = {
	}

extend STCi_fmt
	otawa_sem = {
	}

extend STCr_fmt
	otawa_sem = {
	}

extend CFLi_fmt
	otawa_sem = {
	}


extend CFLri_fmt
	otawa_sem = {
	}

extend CFLrs_fmt
	otawa_sem = {
	}

extend CFLrt_fmt
	otawa_sem = {
	}

