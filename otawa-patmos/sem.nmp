// canonicals
canon s32 "_R"(u32)
canon s32 "_S"(u32) 
canon bit "_P"(u32) 
canon u32 "_MCB"

canon "_NOP"()
canon "_BRANCH"(u32)
canon "_TRAP"()
canon "_CONT"()
canon "_IF"(u32, u32, u32)
canon "_LOAD"(u32, u32, u32)
canon "_STORE"(u32, u32, u32)
canon "_SCRATCH"(u32)
canon "_SET"(u32, u32)
canon "_SETI"(u32, s32)
canon "_CMP"(u32, s32, s32)
canon "_CMPU"(u32, u32, u32)
canon "_ADD"(u32, u32, u32)
canon "_SUB"(u32, u32, u32)
canon "_SHL"(u32, u32, u32)
canon "_SHR"(u32, u32, u32)
canon "_ASR"(u32, u32, u32)
canon "_NOT"(u32, u32)
canon "_AND"(u32, u32, u32)
canon "_OR"(u32, u32, u32)
canon "_MUL"(s32, s32, s32)
canon "_MULU"(u32, u32, u32)
canon "_XOR"(u32, u32, u32)

// condition codes
canon u32 "_NO_COND"
canon u32 "_EQ"
canon u32 "_LT"
canon u32 "_LE"
canon u32 "_GE"
canon u32 "_GT"
canon u32 "_ANY_COND"
canon u32 "_NE"
canon u32 "_ULT"
canon u32 "_ULE"
canon u32 "_UGE"
canon u32 "_UGT"

// special registers
macro SZ = "_S"(0) 
macro SM = "_S"(1) 
macro SL = "_S"(2) 
macro SH = "_S"(3) 
macro SS = "_S"(5) 
macro ST = "_S"(6) 
macro SRB = "_S"(7) 
macro SRO = "_S"(8) 
macro SXB = "_S"(9) 
macro SXO = "_S"(10)

// operands
let T1 = -1
let T2 = -2
macro RD = "_R"(rd.value)
macro RS1 = "_R"(rs1.value)
macro RS2 = "_R"(rs2.value)
macro PD = "_R"(pd.value)
macro PS1 = "_R"(ps1.value)
macro PS2 = "_R"(ps2.value)

// operations
macro NOP = "_NOP"()
macro BRANCH(a) = "_BRANCH"(a)
macro TRAP = "_TRAP"()
macro CONT = "_CONT"()
macro IF(a,b,c) = "_IF"(a,b,c)
macro LOAD(d, s1, s2) = "_LOAD"(d, s1, s2)
macro STORE(d, s1, s2) = "_STORE"(d, s1, s2)
macro SCRATCH(d) = "_SCRATCH"(d)
macro SET(d, s) = "_SET"(d, s)
macro SETI(d, i) = "_SETI"(d, i)
macro CMP(d, s1, s2) = "_CMP"(d, s1, s2)
macro CMPU(d, s1, s2) = "_CMPU"(d, s1, s2)
macro ADD(d, s1, s2) = "_ADD"(d, s1, s2)
macro SUB(d, s1, s2) = "_SUB"(d, s1, s2)
macro SHL(d, s1, s2) = "_SHL"(d, s1, s2)
macro SHR(d, s1, s2) = "_SHR"(d, s1, s2)
macro ASR(d, s1, s2) = "_ASR"(d, s1, s2)
macro NOT(d, s) = "_NOT"(d, s)
macro AND(d, s1, s2) = "_AND"(d, s1, s2)
macro OR(d, s1, s2) = "_OR"(d, s1, s2)
macro MUL(d, s1, s2) = "_MUL"(d, s1, s2)
macro MULU(d, s1, s2) = "_MULU"(d, s1, s2)
macro XOR(d, s1, s2) = "_XOR"(d, s1, s2)

macro SHLI(d, s, i) = "_SETI"(T1, i); "_SHL"(d, s, T1)
macro SHRI(d, s, i) = "_SETI"(T1, i); "_SHR"(d, s, T1)
macro ASHRI(d, s, i) = "_SETI"(T1, i); "_ASR"(d, s, T1)
macro ADDI(d, s, i) = "_SETI"(T1, i); "_ADD"(d, s, T1)
macro SUBI(d, s, i) = "_SETI"(T1, i); "_SUB"(d, s, T1)
macro ANDI(d, s, i) = "_SETI"(T1, i); "_AND"(d, s, T1)
macro XORI(d, s, i) = "_SETI"(T1, i); "_XOR"(d, s, T1)

// temporaries
var t1[1, u32]
var t2[1, u32]

extend reg_idx
	value = i

extend sreg_idx
	value = i

extend pred_idx
	value = i

extend npred_idx, gpred_idx
	value = i
	negated = n

extend ALU_op
	opcode = opc

extend ALU_extop
	opcode = opc

extend ALUc_op
	opcode = opc

extend ALUp_op
	opcode = opc

// Note: This macro uses T1!
macro GET_PRED(d, p) = \
        if p.negated then \
	  XORI(d, "_P"(p.value), 1); \
	else \
          SET(d, "_P"(p.value)); \
	endif

macro SET_PRED(p, s, op) = SETI(p, 0); IF(s, op, 1); SETI(p, 1)

// Note: this macro uses T1 and T2
macro ALU_semop(opc, d, s1, s2) = \
	  switch (opc) { \
	    case 0: ADD(d, s1, s2); \
	    case 1: SUB(d, s1, s2); \
	    case 2: XOR(d, s1, s2); \
	    case 3: SHL(d, s1, s2); \
	    case 4: SHR(d, s1, s2); \
	    case 5: ASR(d, s1, s2); \
	    case 6:  OR(d, s1, s2); \
	    case 7: AND(d, s1, s2); \
	    case 11: OR(T1, s1, s2); NOT(d, T1); \
	    case 12: SHLI(T1, s1, 1); ADD(d, T1, s2); \
	    case 13: SHLI(T1, s1, 1); ADD(d, T1, s2); \
	  }

// Note: Uses T1 and T2
macro ALUc_semop(opc, p, s1, s2) = \
        switch (opc) { \
          case 0: CMP(T1, s1, s2); SET_PRED(p, T1, "_EQ"); \
	  case 1: CMP(T1, s1, s2); SET_PRED(p, T1, "_NE"); \
	  case 2: CMP(T1, s1, s2); SET_PRED(p, T1, "_LT"); \
	  case 3: CMP(T1, s1, s2); SET_PRED(p, T1, "_LE"); \
	  case 4: CMP(T1, s1, s2); SET_PRED(p, T1, "_ULT"); \
	  case 5: CMP(T1, s1, s2); SET_PRED(p, T1, "_ULE"); \
	  case 6: SETI(T1, 1); SHL(T1, T1, s2); AND(T1, s1, T1); \
	          SETI(T2, 0); CMP(T1, T1, T2); SET_PRED(p, T1, "_NE"); \
	}

macro ALUp_semop(opc, p, p1, p2) = \
        switch (opc) { \
	  case 6:   OR(T1, p1, p2); SET(p, T1); \
	  case 7:  AND(T1, p1, p2); SET(p, T1); \
	  case 10: XOR(T1, p1, p2); SET(p, T1); \
	}

extend Pred_fmt
	otawa_sem = {
	  if !guard.always_true then
	    GET_PRED(T2, guard);
	    SETI(T1, 1);
	    CMP(T1, T2, T1);
	    IF(T1, "_NE", 1);
	    CONT;
	  endif;
	  x.otawa_sem;
	}

extend ALUi_fmt
	otawa_sem = {
	  if !rd.is_zero then
	    SETI(T2, imm12);
	    ALU_semop(func.opcode, RD, RS1, T2);
	  endif;
	}

extend ALUl_fmt
	otawa_sem = {
	  if !rd.is_zero then
	    SETI(T2, imm32);
	    ALU_semop(func.opcode, RD, RS1, T2);
	  endif;
	}

extend ALUr_fmt
	otawa_sem = {
	  if !rd.is_zero then
	    ALU_semop(func.opcode, RD, RS1, RS2);
	  endif;
	}

extend ALUm_fmt
	otawa_sem = {
	  if func.is_unsigned then
	    MULU(SL, RS1, RS2);
	  else
	    MUL(SL, RS1, RS2);
	  endif;
	  // For now, do not calculate the high word..
	  SCRATCH(SH);
	}

extend ALUc_fmt
	otawa_sem = {
	  ALUc_semop(func.opcode, PD, RS1, RS2);
	}

extend ALUci_fmt
	otawa_sem = {
	  SETI(T2, imm5);
	  ALUc_semop(func.opcode, PD, RS1, T2);
	}

extend ALUp_fmt
	otawa_sem = {
	  GET_PRED(T1, ps1);
	  GET_PRED(T2, ps2);
	  ALUp_semop(func.opcode, PD, T1, T2);
	}

extend ALUb_fmt
	otawa_sem = {
	}

extend SPCw_fmt
	otawa_sem = {
	  // Just waits..
	}

extend SPCt_fmt
	otawa_sem = {
	  SET("_S"(sd.value), RS1);
	}

extend SPCf_fmt
	otawa_sem = {
	  SET(RD, "_S"(ss.value));
	}

extend LDT_fmt
	otawa_sem = {
	}

extend STT_fmt
	otawa_sem = {
	}

extend STCi_fmt
	otawa_sem = {
	  SCRATCH(SS);
	  SCRATCH(ST);
	}

extend STCr_fmt
	otawa_sem = {
	  SCRATCH(SS);
	  SCRATCH(ST);
	}

extend CFLi_fmt
	otawa_sem = {
	}


extend CFLri_fmt
	otawa_sem = {
	}

extend CFLrs_fmt
	otawa_sem = {
	}

extend CFLrt_fmt
	otawa_sem = {
	}

