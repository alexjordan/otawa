
// ========================================================================= //
// read and written regs information coding
// ========================================================================= //

// USED_REGS will be the name of the extern function which will process the informations
// the function will accept an undefinited number of arguments.
// in C code the real function name can be redefined at will
// with #define USED_REGS other_function

// access types
let READ_REG    = 1
let WRITE_REG   = 2
let REG_RANGE   = 0x10
let READ_RANGE  = READ_REG | REG_RANGE
let WRITE_RANGE = WRITE_REG | REG_RANGE
// used by the extern function,
// this codes an unused argument, useful for multiple "conditional" arguments
let NO_REG      = -1
// codes the end of argument list
let end     = 0


// reg banks macros
let BANK_R	= 1
let BANK_F	= 2

let BANK_PC	= 3
let BANK_nPC	= 4
let BANK_Y	= 5
let BANK_WIM	= 6
let BANK_PSR	= 7
let BANK_FSR	= 8
let BANK_ASR	= 9
let BANK_TBR	= 10


// reg access macros

// for the main banks

macro r_rd(n) = \
	((READ_REG << 24) | (BANK_R << 16) | ((n) & 0xFFFF)) \

macro r_wr(n) = \
	(if (n) == 0 then \
		NO_REG \
	else \
		((WRITE_REG << 24) | (BANK_R << 16) | ((n) & 0xFFFF)) \
	endif) \

macro r_rd_rng(l, u) = \
	((READ_RANGE << 24) | (BANK_R << 16) | (((l) & 0xFF) << 8) | ((u) & 0xFF)) \

macro r_wr_rng(l, u) = \
	(if (l) == 0 then \
		((WRITE_RANGE << 24) | (BANK_R << 16) | (((1) & 0xFF) << 8) | ((u) & 0xFF)) \
	else \
		((WRITE_RANGE << 24) | (BANK_R << 16) | (((l) & 0xFF) << 8) | ((u) & 0xFF)) \
	endif) \


macro f_rd(n) = \
	((READ_REG << 24) | (BANK_F << 16) | ((n) & 0xFFFF)) \
macro f_wr(n) = \
	((WRITE_REG << 24) | (BANK_F << 16) | ((n) & 0xFFFF)) \
macro f_rd_rng(l, u) = \
	((READ_RANGE << 24) | (BANK_F << 16) | (((l) & 0xFF) << 8) | ((u) & 0xFF)) \
macro f_wr_rng(l, u) = \
	((WRITE_RANGE << 24) | (BANK_F << 16) | (((l) & 0xFF) << 8) | ((u) & 0xFF)) \


macro pc_rd = \
	((READ_REG << 24) | (BANK_PC << 16)) \
macro pc_wr = \
	((WRITE_REG << 24) | (BANK_PC << 16)) \

macro npc_rd = \
	((READ_REG << 24) | (BANK_nPC << 16)) \
macro npc_wr = \
	((WRITE_REG << 24) | (BANK_nPC << 16)) \

macro y_rd = \
	((READ_REG << 24) | (BANK_Y << 16)) \
macro y_wr = \
	((WRITE_REG << 24) | (BANK_Y << 16)) \

macro wim_rd = \
	((READ_REG << 24) | (BANK_WIM << 16)) \
macro wim_wr = \
	((WRITE_REG << 24) | (BANK_WIM << 16)) \

macro psr_rd = \
	((READ_REG << 24) | (BANK_PSR << 16)) \
macro psr_wr = \
	((WRITE_REG << 24) | (BANK_PSR << 16)) \

macro fsr_rd = \
	((READ_REG << 24) | (BANK_FSR << 16)) \
macro fsr_wr = \
	((WRITE_REG << 24) | (BANK_FSR << 16)) \

macro asr_rd = \
	((READ_REG << 24) | (BANK_ASR << 16)) \
macro asr_wr = \
	((WRITE_REG << 24) | (BANK_ASR << 16)) \

macro tbr_rd = \
	((READ_REG << 24) | (BANK_TBR << 16)) \
macro tbr_wr = \
	((WRITE_REG << 24) | (BANK_TBR << 16)) \


// generic
macro reg_read(bank, n) = \
	((READ_REG << 24) | ((bank & 0xFF) << 16) | ((n) & 0xFFFF)) \
macro reg_write(bank, n) = \
	((WRITE_REG << 24) | ((bank & 0xFF) << 16) | ((n) & 0xFFFF)) \
macro reg_read_range(bank, l, u) = \
	((READ_RANGE << 24) | ((bank & 0xFF) << 16) | (((l) & 0xFF) << 8) | ((u) & 0xFF)) \
macro reg_write_range(bank, l, u) = \
	((WRITE_RANGE << 24) | ((bank & 0xFF) << 16) | (((l) & 0xFF) << 8) | ((u) & 0xFF)) \


// list of used registers for each instruction

extend ldsb, ldsh, ldub, ld
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, end)
extend ldd
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value | 1), r_wr(rd.value & 0xFE), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, end)
extend ldsba, ldsha, lduba, lda
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_rd(rs2.idx), r_wr(rd.value), end)
extend ldda
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_rd(rs2.idx), r_wr(rd.value | 1), r_wr(rd.value & 0xFE), end)
extend ldf
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, f_wr(rd.value), end)
extend lddf
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, f_wr(rd.value | 1), f_wr(rd.value & 0xFE), end)
extend ldfsr
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, fsr_wr, end)

extend stb, sth, st
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_rd(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, end)
extend std
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_rd(rd.value | 1), r_rd(rd.value & 0xFE), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, end)
extend stha, stba, sta
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_rd(rs2.idx), r_rd(rd.value), end)
extend stda
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_rd(rs2.idx), r_rd(rd.value | 1), r_rd(rd.value & 0xFE), end)
extend stf
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, f_rd(rd.value), end)
extend stdf
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, f_rd(rd.value | 1), f_rd(rd.value & 0xFE), end)
extend stfsr
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, fsr_rd, end)

extend ldstub
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, end)
extend ldstuba
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), r_rd(rs2.idx), end)
extend swap
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), r_rd(rd.value), if i == 1 then r_rd(rs2.idx) else  NO_REG endif, end)
extend swapa
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), r_rd(rd.value), r_rd(rs2.idx), end)


extend sethi
	otawa_used_regs = "USED_REGS"(r_wr(rd.value), end)

extend and, andn, or, orn, xor, xnor, sll, srl, sra, add, addx, sub, subx
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, end)
extend andcc, andncc, orcc, orncc, xorcc, xnorcc, addcc, addxcc, subcc, subxcc, taddcc, taddcctv, tsubcc, tsubcctv
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, psr_wr, end)

extend mulscc
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, y_rd, y_wr, psr_wr, end)
extend umul, smul
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, y_wr, end)
extend umulcc, smulcc
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, y_wr, psr_wr, end)

extend udiv, sdiv
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, y_rd, end)
extend udivcc, sdivcc
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, y_rd, psr_wr, end)

extend save, restore
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, psr_wr, end)

extend bicc
	otawa_used_regs = "USED_REGS"(npc_wr, if cond.value == 8 then NO_REG else psr_rd endif, end)
extend fbfcc
	otawa_used_regs = "USED_REGS"(fsr_rd, npc_wr, end)
extend call
	otawa_used_regs = "USED_REGS"(r_wr(15), npc_wr, pc_rd, end)
extend jmpl
	otawa_used_regs = "USED_REGS"(r_rd(rs1.value), r_wr(rd.value), if i == 0 then r_rd(rs2.idx) else  NO_REG endif, pc_rd, npc_wr, end)


// now the floating point instructions

extend fitos, fstoi, fmovs, fnegs, fabss, fsqrts
	otawa_used_regs = "USED_REGS"(f_rd(rs2.value), f_wr(rd.value), end)
extend fitod, fstod
	otawa_used_regs = "USED_REGS"(f_rd(rs2.value), f_wr(rd.value & 0x0fe), f_wr(rd.value | 1), end)
extend fdtoi, fdtos
	otawa_used_regs = "USED_REGS"(f_rd(rs2.value & 0xfe), f_rd(rs2.value | 1), f_wr(rd.value), end)
extend fsqrtd
	otawa_used_regs = "USED_REGS"(f_rd(rs2.value & 0xfe), f_rd(rs2.value | 1), f_wr(rd.value & 0x0fe), f_wr(rd.value | 1), end)

extend fadds, fsubs, fmuls, fdivs
	otawa_used_regs = "USED_REGS"(f_rd(rs1.value), f_rd(rs2.value), f_wr(rd.value), end)
extend faddd, fsubd, fmuld, fdivd
	otawa_used_regs = "USED_REGS"(f_rd(rs1.value & 0xfe), f_rd(rs1.value | 1), f_rd(rs2.value & 0xfe), f_rd(rs2.value | 1), f_wr(rd.value & 0x0fe), f_wr(rd.value | 1), end)
extend  fsmuld
	otawa_used_regs = "USED_REGS"(f_rd(rs1.value), f_rd(rs2.value), f_wr(rd.value & 0x0fe), f_wr(rd.value | 1), end)

extend fcmps
	otawa_used_regs = "USED_REGS"(f_rd(rs1.value), f_rd(rs2.value), fsr_wr, end)
extend fcmpd
	otawa_used_regs = "USED_REGS"(f_rd(rs1.value & 0xfe), f_rd(rs1.value | 1), f_rd(rs2.value & 0xfe), f_rd(rs2.value | 1), fsr_wr, end)

